# 兽音解密（RoarCodec）

本项目是一个基于 Godot 引擎的文本加密/解密工具，核心算法实现见 [`RoarCodec.gd`](RoarCodec.gd)。本说明将详细讲解加密与解密算法的原理与实现。

## 算法原理

### 1. 密钥要求

- 密钥（codec）必须为**4个互不相同的字符**。
- 若密钥无效，编码/解码会失败。

### 2. 加密流程（[`RoarCodec.encode`](RoarCodec.gd)）

1. **明文转16进制**  
   - 遍历明文每个字符，将其转为 UTF-16 编码（高字节在前，大端序）。
   - 每个字节转为2位16进制字符串，依次拼接成 hex 字符串数组。

2. **加扰映射**  
   - 遍历 hex 数组，每个字符转为 0~15 的整数。
   - 对每个整数加上其索引 mod 16 的偏移，再对16取模。
   - 用密钥的4个字符做如下映射：
     - 高2位（value / 4）和低2位（value % 4）分别用密钥的对应字符替换。
     - / 4 是为了将高4位映射到密钥的索引，即 >> 2
     - % 4 是为了将低4位映射到密钥的索引，即 & 0b011
     - 得到的结果始终是在0~3之间的密钥索引。
   - 拼接所有映射结果。

3. **密文结构**  
   - 最终密文格式为：`codec[3] + codec[1] + codec[0] + <映射结果> + codec[2]`
   - 例如密钥为“嗷呜啊\~”，则密文头3位和尾1位分别为“~呜嗷啊”。

### 3. 解密流程（[`RoarCodec.decode`](RoarCodec.gd)）

1. **提取有效密文段**  
   - 使用 `_extract_encoded_segment`，根据 fallback 关键字或默认规则提取有效密文部分。

2. **密钥还原**  
   - 通过密文头3位和尾1位还原密钥顺序：`key = segment[2] + segment[1] + segment[-1] + segment[0]`

3. **映射还原**  
   - 去掉头3位和尾1位，得到原始映射内容。
   - 每2个字符一组，查找在密钥中的索引，反推原始16进制数值。
   - `a`即高二位得出的索引，`b`即低二位得出的索引。
   - 逆向偏移：`index = (4 * a + b - (i / 2 % 16) + 16) % 16`

4. **明文还原**  
   - 每4个16进制字符拼成一个UTF-16字符，转为明文。

### 4. 其他辅助函数

- `is_valid_codec(codec: String)`：校验密钥有效性（长度4且无重复）。
- `_distinct(input: String)`：去重字符串中的字符。
- `_extract_encoded_segment(input: String)`：根据 fallback 关键字提取密文段，兼容不同格式。

## 示例

### 加密

```gdscript
var cipher = RoarCodec.encode("你好", "嗷呜啊~")
print(cipher) # 输出加密后的密文
```

### 解密

```gdscript
var plain = RoarCodec.decode(cipher)
print(plain) # 输出原始明文
```

## 过程演示

### 加密

明文：你好
密钥：嗷呜啊~

1. 将“你好”转化为4位16进制大端序：
   - GDScript:
      默认转化为小端序十进制数：`[96, 79], [125, 89]`
      需要手动翻转，并以格式化字符串转化为大端序16进制: `0x4F60, 0x597D`
   - C#: 0x4F60, 0x597D
2. 加入字符串数值：
   - GDScript：`[4, F, 6, 0, 5, 9, 7, D]`, 
   - C#：`[4F60, 597D]`
3. 遍历数组，从密钥中映射字符串：   
   | 索引 |  当前值 | 转化为10进制 |         加偏移      |  模16(限制范围) |                              获取映射的索引                             | 第一个字符 | 第二个字符 |
   |-----|---------|-------------|--------------------|----------------|------------------------------------------------------------------------|----------|-----------|
   |  0  |  `0x4`  |      4      | `4 + 0 % 16 = 4`   | `4 % 16 = 4`   | `4 / 4 = 1`  `0100 >> 2 = 0001` <br> `4 % 4 = 0`  `0100 & 0011 = 0000` |    呜    |     嗷    |
   |  1  |  `0xF`  |      15     | `15 + 1 % 16 = 16` | `16 % 16 = 0`  | `0 / 4 = 0`  `0000 >> 2 = 0000` <br> `0 % 4 = 0`  `0000 & 0011 = 0000` |    嗷    |     嗷    |
   |  2  |  `0x6`  |      6      | `6 + 2 % 16 = 8`   | `8 % 16 = 8`   | `8 / 4 = 2`  `1000 >> 2 = 0010` <br> `8 % 4 = 0`  `1000 & 0011 = 0000` |    啊    |     嗷    |
   |  3  |  `0x0`  |      0      | `0 + 3 % 16 = 3`   | `3 % 16 = 3`   | `3 / 4 = 0`  `0011 >> 2 = 0000` <br> `3 % 4 = 3`  `0011 & 0011 = 0011` |    嗷    |     ~     |
   |  4  |  `0x5`  |      5      | `5 + 4 % 16 = 9`   | `9 % 16 = 9`   | `9 / 4 = 2`  `1001 >> 2 = 0010` <br> `9 % 4 = 1`  `1001 & 0011 = 0001` |    啊    |     呜    |
   |  5  |  `0x9`  |      9      | `9 + 5 % 16 = 14`  | `14 % 16 = 14` | `14 / 4 = 3` `1110 >> 2 = 0011` <br> `14 % 4 = 2` `1110 & 0011 = 0010` |    ~     |    啊     |
   |  6  |  `0x7`  |      7      | `7 + 6 % 16 = 13`  | `13 % 16 = 13` | `13 / 4 = 3` `1101 >> 2 = 0011` <br> `13 % 4 = 1` `1101 & 0011 = 0001` |    ~     |     呜    |
   |  7  |  `0xD`  |      13     | `13 + 7 % 16 = 20` | `20 % 16 = 4`  | `4 / 4 = 1`  `0100 >> 2 = 0001` <br> `4 % 4 = 0`  `0100 & 0011 = 0000` |    呜    |     嗷    |   
4. 构成最终密文：第四个字符 + 第二个字符 + 第一个字符 + 映射后的字符串 + 第三个字符：
   "~" + "呜" + "嗷" + "呜嗷嗷嗷啊嗷嗷\~啊呜\~啊~呜呜嗷" + "啊"
5. 得到最终密文：`~呜嗷呜嗷嗷嗷啊嗷嗷~啊呜~啊~呜呜嗷啊`
  
#### 解密

密文：\~呜嗷呜嗷嗷嗷啊嗷嗷\~啊呜\~啊\~呜呜嗷啊

1. 提取密钥：密文第三个字符 + 密文第二个字符 + 密文最后一个字符 + 密文第一个字符 → "嗷" + "呜" + "啊" + "~"
2. 提取原始映射：密文去掉头3位和尾1位，得到原始映射内容 → 呜嗷嗷嗷啊嗷嗷\~啊呜\~啊~呜呜嗷
3. 两两一组遍历原始映射，恢复为十六进制字符串：
   | 偶数索引 `i` | 原字符 A | 原字符 B | 密钥中 A 的索引（a）|密钥中 B 的索引（b） | 还原混淆值 `(a << 2) \| b` | 计算偏移 `(i / 2) % 16` | 减去偏移 `value - offset` | 加上 16 保证非负 | `% 16` 限制为 `0~15` | 还原十六进制 |
   |---|----|---|-------------------------------|------------------------------|-------------------------------------------------------------|--------------------|-------------|---------------|---------------|-------|
   | 0 | 呜 | 嗷 | `"嗷呜啊~".IndexOf("呜") = 1` | `"嗷呜啊~".IndexOf("嗷") = 0` | `1 * 4 + 0 = 4`<br>`0001 << 2 = 0100` `0100 \| 0000 = 0100` | `(0 / 2) % 16 = 0` | `4 - 0 = 4` | `4 + 16 = 20` | `20 % 16 = 4` | `0x4` |
   | 2 | 嗷 | 嗷 | `"嗷呜啊~".IndexOf("嗷") = 0` | `"嗷呜啊~".IndexOf("嗷") = 0` | `0 * 4 + 0 = 0`<br>`0000 << 2 = 0000` `0000 \| 0000 = 0000` | `(2 / 2) % 16 = 1` | `0 - 1 = -1`| `-1 + 16 = 15` | `15 % 16 = 15` | `0xF` |
   | 4 | 啊 | 嗷 | `"嗷呜啊~".IndexOf("啊") = 2` | `"嗷呜啊~".IndexOf("嗷") = 0` | `2 * 4 + 0 = 8`<br>`0010 << 2 = 1000` `1000 \| 0000 = 1000` | `(4 / 2) % 16 = 2` | `8 - 2 = 6` | `6 + 16 = 22` | `22 % 16 = 6` | `0x6` |
   | 6 | 嗷 | ~ | `"嗷呜啊~".IndexOf("嗷") = 0` | `"嗷呜啊~".IndexOf("~") = 3`   | `0 * 4 + 3 = 3`<br>`0000 << 2 = 0000` `0000 \| 0011 = 0011` | `(6 / 2) % 16 = 3` | `3 - 3 = 0` | `0 + 16 = 16` | `16 % 16 = 0` | `0x0` |
   | 8 | 啊 | 呜 | `"嗷呜啊~".IndexOf("啊") = 2` | `"嗷呜啊~".IndexOf("呜") = 1` | `2 * 4 + 1 = 9`<br>`0010 << 2 = 1000` `1000 \| 0001 = 1001` | `(8 / 2) % 16 = 4` | `9 - 4 = 5` | `5 + 16 = 21` | `21 % 16 = 5` | `0x5` |
   | 10 | ~ | 啊 | `"嗷呜啊~".IndexOf("~") = 3` | `"嗷呜啊~".IndexOf("啊") = 2` | `3 * 4 + 2 = 14`<br>`0011 << 2 = 1100` `1100 \| 0010 = 1110` | `(10 / 2) % 16 = 5` | `14 - 5 = 9` | `9 + 16 = 25` | `25 % 16 = 9` | `0x9` |
   | 12 | ~ | 呜 | `"嗷呜啊~".IndexOf("~") = 3` | `"嗷呜啊~".IndexOf("呜") = 1` | `3 * 4 + 1 = 13`<br>`0011 << 2 = 1100` `1100 \| 0001 = 1101` | `(12 / 2) % 16 = 6` | `13 - 6 = 7` | `7 + 16 = 23` | `23 % 16 = 7` | `0x7` |
   | 14 | 呜 | 嗷 | `"嗷呜啊~".IndexOf("呜") = 1` | `"嗷呜啊~".IndexOf("嗷") = 0` | `1 * 4 + 0 = 4`<br>`0001 << 2 = 0100` `0100 \| 0000 = 0100` | `(14 / 2) % 16 = 7` | `4 - 7 = -3` | `-3 + 16 = 13` | `13 % 16 = 13` | `0xD` |
4. 得到还原后的十六进制字符串数组：`[4, F, 6, 0, 5, 9, 7, D]`
5. 四四一组遍历字符串数组，将四位十六进制数转换为十进制，再转换为UTF-16字符：
   | 起始索引 `i` | `hex[i ~ i+3]`（4位） | 拼接后 `part` | 转换为十进制（`part.hex_to_int()`） | 将十进制数Unicode码/ASCII码转为字符 `char(十进制)` |
   | ----------- | -------------------- | ------------- | --------------------------------- | ----------------------------------------------- |
   | 0           |  `4`, `F`, `6`, `0`  |   `"4F60"`    |        `0x4F60 = 20320`           |                          `你`                   | 
   | 4           |  `5`, `9`, `7`, `D`  |   `"597D"`    |        `0x597D = 22826`           |                          `好`                   |
6. 拼接所有字符得到明文：`"你好"`




## 文件结构

- [`RoarCodec.gd`](RoarCodec.gd)：核心加解密算法实现
- [`RoarCodec.cs`](RoarCodec.cs): C#实现
- [`main.gd`](main.gd)：界面逻辑
- [`main.tscn`](main.tscn)：界面布局

## 注意事项

- 密钥必须为4个互不相同的字符，否则加密/解密会失败。
- 若密文或密钥无效，函数会返回空字符串并输出错误信息。

---

如需进一步了解算法实现，请查阅 [`RoarCodec.gd`](RoarCodec.gd) / [`RoarCodec.cs`](RoarCodec.cs)源码